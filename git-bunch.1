.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GIT-BUNCH 1"
.TH GIT-BUNCH 1 "2020-10-23" "GIT-BUNCH(1)" "Git Manual"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
git\-bunch \- manage bunch directories which contain git repositories
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  git\-bunch \-h | \-\-help
\&  git\-bunch \-l | \-\-list
\&  git\-bunch NAME
\&  git\-bunch NAME ls
\&  git\-bunch NAME config \-l | \-\-list
\&  git\-bunch NAME config config\-name [config\-value]
\&  git\-bunch NAME [\-\-] COMMAND [OPTIONS]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
git-bunch or bunch is a term to refer to a directory which is supposed to be a container for other directories being containers of git repositories.
.PP
If you keep your repos under some directory...
.PP
If you need to execute (sometimes, not so often) some particular git commands over these repos...
.PP
\&... this script for you!
.SH "CONFIGURE BUNCHES"
.IX Header "CONFIGURE BUNCHES"
The script assumes that all bunches and their settings are stored globally in the \f(CW\*(C`~/.gitconfig\*(C'\fR file.
.PP
You can declare more than one bunch. Each directory containing git repositories can be called a bunch. Each bunch has a name, path and options. The name is used to refer the bunch. The path is used to locate the bunch. Options are used to tune the bunch. There is no restriction to declare more than one name per a bunch. In this case both names are synonyms, but they could have different options.
.SH "CONFIGURATION FILE"
.IX Header "CONFIGURATION FILE"
Git bunch is per-user configuration only. That means that all bunches are configured via user's \f(CW\*(C`~/.gitconfig\*(C'\fR. The syntax is \fBalmost\fR the same as for \f(CW\*(C`gitconfig\*(C'\fR.
.SS "Syntax"
.IX Subsection "Syntax"
In this example two bunches called \*(L"one\*(R" and \*(L"two\*(R" are created and setup to particular directories:
.PP
.Vb 6
\&  [bunch "one"]
\&    path = /var/git/bunch\-1
\&    stoponerror = no
\&  [bunch "two"]
\&    path = /var/git/bunch\-2
\&    stoponerror = no
.Ve
.SS "Values"
.IX Subsection "Values"
.IP "pathname" 4
.IX Item "pathname"
A pathname follows Bash syntax.
.IP "boolean" 4
.IX Item "boolean"
The following words stand for \fBtrue\fR and \fBfalse\fR:
.RS 4
.IP "true" 4
.IX Item "true"
Boolean true literals are \f(CW\*(C`yes\*(C'\fR, \f(CW\*(C`on\*(C'\fR, \f(CW\*(C`true\*(C'\fR, \f(CW1\fR.
.Sp
\&\fBIn contrast to git itself\fR, the single name (without \f(CW\*(C`= value\*(C'\fR) is treated as false.
.IP "false" 4
.IX Item "false"
Boolean false literals are \f(CW\*(C`no\*(C'\fR, \f(CW\*(C`off\*(C'\fR, \f(CW\*(C`false\*(C'\fR, \f(CW0\fR and the emtpy string.
.RE
.RS 4
.RE
.SS "Variables"
.IX Subsection "Variables"
The following variables are supported for bunches:
.ie n .IP """path"" (string)" 4
.el .IP "\f(CWpath\fR (string)" 4
.IX Item "path (string)"
The only mandatory variable defining the bunch location.
.ie n .IP """stoponerror"" (boolean)" 4
.el .IP "\f(CWstoponerror\fR (boolean)" 4
.IX Item "stoponerror (boolean)"
True means stop immediately if a command exits with a non-zero status. Defaults to false (i.e., \f(CW\*(C`set +o errexit\*(C'\fR).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Something similar...
.IP "https://metacpan.org/pod/Git::Bunch" 4
.IX Item "https://metacpan.org/pod/Git::Bunch"
Something very similar, implemented in pure Perl
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2020 Ildar Shaimordanov. \s-1MIT\s0 License.
